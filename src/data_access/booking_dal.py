"""
Data Access Layer for Booking operations.

Handles all database operations related to bookings including
conflict detection, status management, and scheduling logic.
"""
# AI Contribution: Conflict detection logic generated by Cursor AI; team added edge case handling

from src.models.database import get_db_connection
from datetime import datetime, timedelta


class BookingDAL:
    """Data Access Layer for Booking entity."""
    
    @staticmethod
    def create_booking(resource_id, requester_id, start_datetime, end_datetime, 
                      status='pending', notes=None):
        """
        Create a new booking request.
        
        Args:
            resource_id (int): ID of resource being booked
            requester_id (int): ID of user requesting booking
            start_datetime (str/datetime): Booking start time
            end_datetime (str/datetime): Booking end time
            status (str): Initial status (default: 'pending')
            notes (str, optional): Additional booking notes
            
        Returns:
            int: ID of newly created booking
            
        Raises:
            ValueError: If booking conflicts with existing bookings
        """
        # Check for conflicts
        if BookingDAL.has_conflict(resource_id, start_datetime, end_datetime):
            raise ValueError("Booking conflicts with existing reservation")
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT INTO bookings 
            (resource_id, requester_id, start_datetime, end_datetime, status, notes)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (resource_id, requester_id, start_datetime, end_datetime, status, notes))
        
        booking_id = cursor.lastrowid
        conn.commit()
        conn.close()
        
        return booking_id
    
    @staticmethod
    def has_conflict(resource_id, start_datetime, end_datetime, exclude_booking_id=None):
        """
        Check if a booking would conflict with existing bookings.
        
        A conflict occurs when time ranges overlap and the existing booking
        is in 'approved' or 'pending' status.
        
        Args:
            resource_id (int): Resource to check
            start_datetime (str/datetime): Proposed start time
            end_datetime (str/datetime): Proposed end time
            exclude_booking_id (int, optional): Booking ID to exclude (for updates)
            
        Returns:
            bool: True if conflict exists, False otherwise
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # Query for overlapping bookings
        # Overlap condition: (start1 < end2) AND (start2 < end1)
        query = """
            SELECT COUNT(*) as conflict_count
            FROM bookings
            WHERE resource_id = ?
              AND status IN ('approved', 'pending')
              AND start_datetime < ?
              AND end_datetime > ?
        """
        params = [resource_id, end_datetime, start_datetime]
        
        if exclude_booking_id:
            query += " AND booking_id != ?"
            params.append(exclude_booking_id)
        
        cursor.execute(query, params)
        result = cursor.fetchone()
        conn.close()
        
        return result['conflict_count'] > 0
    
    @staticmethod
    def get_booking_by_id(booking_id):
        """
        Retrieve a booking by ID with related resource and user info.
        
        Args:
            booking_id (int): Booking ID
            
        Returns:
            sqlite3.Row: Booking record with resource and user info
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT b.*, 
                   r.title as resource_title, r.location as resource_location,
                   r.owner_id as resource_owner_id,
                   u.name as requester_name, u.email as requester_email
            FROM bookings b
            JOIN resources r ON b.resource_id = r.resource_id
            JOIN users u ON b.requester_id = u.user_id
            WHERE b.booking_id = ?
        """, (booking_id,))
        
        booking = cursor.fetchone()
        conn.close()
        
        return booking
    
    @staticmethod
    def get_bookings_for_user(user_id, status=None, upcoming_only=False):
        """
        Get all bookings for a specific user.
        
        Args:
            user_id (int): User ID
            status (str, optional): Filter by status
            upcoming_only (bool): Only return future bookings
            
        Returns:
            list: List of booking records
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT b.*, r.title as resource_title, r.location as resource_location
            FROM bookings b
            JOIN resources r ON b.resource_id = r.resource_id
            WHERE b.requester_id = ?
        """
        params = [user_id]
        
        if status:
            query += " AND b.status = ?"
            params.append(status)
        
        if upcoming_only:
            query += " AND b.start_datetime > datetime('now')"
        
        query += " ORDER BY b.start_datetime DESC"
        
        cursor.execute(query, params)
        bookings = cursor.fetchall()
        conn.close()
        
        return bookings
    
    @staticmethod
    def get_bookings_for_resource(resource_id, status=None):
        """
        Get all bookings for a specific resource.
        
        Args:
            resource_id (int): Resource ID
            status (str, optional): Filter by status
            
        Returns:
            list: List of booking records
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT b.*, u.name as requester_name, u.email as requester_email
            FROM bookings b
            JOIN users u ON b.requester_id = u.user_id
            WHERE b.resource_id = ?
        """
        params = [resource_id]
        
        if status:
            query += " AND b.status = ?"
            params.append(status)
        
        query += " ORDER BY b.start_datetime"
        
        cursor.execute(query, params)
        bookings = cursor.fetchall()
        conn.close()
        
        return bookings
    
    @staticmethod
    def get_pending_approvals(owner_id=None):
        """
        Get all bookings pending approval.
        
        Args:
            owner_id (int, optional): Filter by resource owner
            
        Returns:
            list: List of pending bookings
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT b.*, 
                   r.title as resource_title, r.location as resource_location,
                   r.owner_id,
                   u.name as requester_name, u.email as requester_email
            FROM bookings b
            JOIN resources r ON b.resource_id = r.resource_id
            JOIN users u ON b.requester_id = u.user_id
            WHERE b.status = 'pending'
        """
        params = []
        
        if owner_id:
            query += " AND r.owner_id = ?"
            params.append(owner_id)
        
        query += " ORDER BY b.created_at"
        
        cursor.execute(query, params)
        bookings = cursor.fetchall()
        conn.close()
        
        return bookings
    
    @staticmethod
    def update_booking_status(booking_id, new_status):
        """
        Update the status of a booking.
        
        Args:
            booking_id (int): Booking ID
            new_status (str): New status value
            
        Returns:
            bool: True if update successful
        """
        valid_statuses = ['pending', 'approved', 'rejected', 'cancelled', 'completed']
        if new_status not in valid_statuses:
            raise ValueError(f"Invalid status: {new_status}")
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE bookings 
            SET status = ?, updated_at = CURRENT_TIMESTAMP
            WHERE booking_id = ?
        """, (new_status, booking_id))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def update_booking(booking_id, **kwargs):
        """
        Update booking fields.
        
        Args:
            booking_id (int): Booking ID
            **kwargs: Fields to update
            
        Returns:
            bool: True if update successful
        """
        allowed_fields = ['start_datetime', 'end_datetime', 'notes', 'status']
        update_fields = {k: v for k, v in kwargs.items() if k in allowed_fields}
        
        if not update_fields:
            return False
        
        # If updating times, check for conflicts
        if 'start_datetime' in update_fields or 'end_datetime' in update_fields:
            booking = BookingDAL.get_booking_by_id(booking_id)
            if booking:
                start = update_fields.get('start_datetime', booking['start_datetime'])
                end = update_fields.get('end_datetime', booking['end_datetime'])
                if BookingDAL.has_conflict(booking['resource_id'], start, end, booking_id):
                    raise ValueError("Updated booking conflicts with existing reservation")
        
        conn = get_db_connection()
        cursor = conn.cursor()
        
        update_fields['updated_at'] = datetime.now().isoformat()
        set_clause = ', '.join([f"{field} = ?" for field in update_fields.keys()])
        values = list(update_fields.values()) + [booking_id]
        
        cursor.execute(f"UPDATE bookings SET {set_clause} WHERE booking_id = ?", values)
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def delete_booking(booking_id):
        """
        Delete a booking.
        
        Args:
            booking_id (int): Booking ID
            
        Returns:
            bool: True if deletion successful
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("DELETE FROM bookings WHERE booking_id = ?", (booking_id,))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success
    
    @staticmethod
    def mark_completed_bookings():
        """
        Mark bookings as completed if their end time has passed.
        
        Returns:
            int: Number of bookings marked as completed
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE bookings
            SET status = 'completed', updated_at = CURRENT_TIMESTAMP
            WHERE status = 'approved'
              AND end_datetime < datetime('now')
        """)
        
        count = cursor.rowcount
        conn.commit()
        conn.close()
        
        return count
    
    @staticmethod
    def get_booking_statistics(owner_id=None):
        """
        Get booking statistics for dashboard.
        
        Args:
            owner_id (int, optional): Filter by resource owner
            
        Returns:
            dict: Statistics including counts by status
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        query = """
            SELECT 
                COUNT(*) as total_bookings,
                SUM(CASE WHEN b.status = 'pending' THEN 1 ELSE 0 END) as pending,
                SUM(CASE WHEN b.status = 'approved' THEN 1 ELSE 0 END) as approved,
                SUM(CASE WHEN b.status = 'completed' THEN 1 ELSE 0 END) as completed,
                SUM(CASE WHEN b.status = 'rejected' THEN 1 ELSE 0 END) as rejected,
                SUM(CASE WHEN b.status = 'cancelled' THEN 1 ELSE 0 END) as cancelled
            FROM bookings b
        """
        
        if owner_id:
            query += """
                JOIN resources r ON b.resource_id = r.resource_id
                WHERE r.owner_id = ?
            """
            cursor.execute(query, (owner_id,))
        else:
            cursor.execute(query)
        
        stats = dict(cursor.fetchone())
        conn.close()
        
        return stats
    
    @staticmethod
    def update_calendar_event_id(booking_id, calendar_event_id):
        """
        Update the Google Calendar event ID for a booking.
        
        Args:
            booking_id (int): Booking ID
            calendar_event_id (str): Google Calendar event ID
            
        Returns:
            bool: True if update successful
        """
        conn = get_db_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            UPDATE bookings 
            SET calendar_event_id = ?
            WHERE booking_id = ?
        """, (calendar_event_id, booking_id))
        
        success = cursor.rowcount > 0
        conn.commit()
        conn.close()
        
        return success

